diff --git a/../12-linked-list/linked_list.c b/list_slab.c
index cb604a0..a22d3a3 100644
--- a/../12-linked-list/linked_list.c
+++ b/list_slab.c
@@ -20,13 +20,15 @@ struct identity {
 
 static LIST_HEAD(identity_list);
 
+static struct kmem_cache *identity_cache;
+
 static int identity_create(char *name, int id)
 {
 	struct identity *new_ident;
 
 	// TODO: Look for id in existing list and fail if exists
 
-	new_ident = kmalloc(sizeof(*new_ident), GFP_KERNEL);
+	new_ident = kmem_cache_alloc(identity_cache, GFP_KERNEL);
 	if (new_ident == NULL) {
 		return -EINVAL;
 	}
@@ -56,7 +58,7 @@ static void identity_destroy(int id)
 	struct identity *identity = identity_find(id);
 	if (identity != NULL) {
 		list_del(&(identity->list));
-		kfree(identity);
+		kmem_cache_free(identity_cache, identity);
 	}
 
 }
@@ -67,6 +69,10 @@ static int __init linked_list_start(void)
 
 	pr_info("Loading %s\n", THIS_MODULE->name);
 
+	identity_cache = kmem_cache_create("identity", sizeof(struct identity), 0, 0, NULL);
+	if (identity_cache == NULL)
+		return -ENOMEM;
+
 	if ((identity_create("Alice", 1)) != 0) {
 		return -EINVAL;
 	}
@@ -108,7 +114,9 @@ static int __init linked_list_start(void)
 
 static void __exit linked_list_end(void)
 {
-	printk(KERN_INFO "Unloading %s\n", THIS_MODULE->name);
+	pr_info("Unloading %s\n", THIS_MODULE->name);
+	if (identity_cache)
+		kmem_cache_destroy(identity_cache);
 }
 
 module_init(linked_list_start);
